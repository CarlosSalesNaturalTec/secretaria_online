# Fix Report: feat-007 - Criar migration e model User

**Data do Ajuste:** 2025-10-26 14:30
**Tipo:** üêõ Bug Cr√≠tico

---

## 1. PROBLEMA ORIGINAL

### Descri√ß√£o do Problema
Ao tentar atualizar a senha de um usu√°rio existente usando `user.password = 'novaSenha'` seguido de `user.save()`, o hash da senha n√£o era atualizado no banco de dados. O m√©todo `save()` executava um UPDATE, mas apenas atualizava o campo `updated_at`, mantendo o `password_hash` inalterado.

### Contexto
- **Reportado por:** Desenvolvedor durante execu√ß√£o do teste 19 (teste-senha.js)
- **Ambiente:** Desenvolvimento
- **Impacto:** Cr√≠tico - impede funcionalidade essencial de altera√ß√£o de senha

### Comportamento Esperado
- Atribuir novo valor a `user.password` deveria gerar novo hash
- Chamar `user.save()` deveria persistir o novo hash no banco
- Valida√ß√£o com senha nova deveria retornar `true`
- Valida√ß√£o com senha antiga deveria retornar `false`

### Comportamento Observado
- O setter do campo virtual `password` era executado corretamente
- O hook `beforeValidate` gerava um novo hash corretamente
- **MAS** o Sequelize n√£o inclu√≠a `password_hash` no UPDATE SQL
- Resultado: apenas `updated_at` era atualizado, senha permanecia inalterada

**Output do erro:**
```
Executing (default): UPDATE `users` SET `updated_at`=? WHERE `id` = ?
Hash antigo: $2b$10$QqmXp/9v6zTCn...
Hash novo: $2b$10$QqmXp/9v6zTCn...
Hash foi alterado? ‚úó N√ÉO (ERRO!)
Nova senha v√°lida? ‚úó N√ÉO (ERRO!)
Senha antiga inv√°lida? ‚úó N√ÉO (ERRO!)
```

---

## 2. AN√ÅLISE DA CAUSA RAIZ

### Investiga√ß√£o
1. Criado teste de debug (`teste-debug-senha.js`) para rastrear execu√ß√£o passo a passo
2. Verificado que o setter estava sendo executado (`_passwordNeedsHash` era setado corretamente)
3. Verificado que o hook `beforeValidate` estava gerando novo hash
4. Identificado que `user.changed()` retornava apenas `['password']` (campo virtual), mas n√£o `['password_hash']`
5. Descoberto que o SQL de UPDATE n√£o inclu√≠a `password_hash`

### Causa Identificada
**Problema de timing no ciclo de vida do Sequelize:**

O Sequelize determina quais campos incluir no UPDATE **antes** de executar os hooks de valida√ß√£o. A sequ√™ncia era:

1. ‚úÖ `user.password = 'nova'` ‚Üí Setter executa, marca `_passwordNeedsHash`
2. ‚ùå Sequelize determina campos alterados ‚Üí Detecta apenas `password` (virtual), ignora `password_hash`
3. ‚úÖ Hook `beforeValidate` executa ‚Üí Gera novo hash e atribui a `password_hash`
4. ‚ùå `user.save()` executa UPDATE ‚Üí Mas `password_hash` n√£o est√° na lista de campos alterados
5. ‚ùå Resultado: UPDATE s√≥ inclui `updated_at`

**Causa t√©cnica:**
- Campo `password` √© VIRTUAL (n√£o existe no banco)
- Marca√ß√£o de mudan√ßa em `password_hash` dentro do hook `beforeValidate` ocorria **tarde demais**
- Sequelize j√° havia determinado quais campos incluir no UPDATE

### Arquivos/Componentes Afetados
- `backend/src/models/User.js` - Setter do campo virtual `password` (linha 207-217)
- `backend/src/models/User.js` - Hook `beforeValidate` (linha 283-297)

---

## 3. SOLU√á√ÉO IMPLEMENTADA

### Estrat√©gia de Corre√ß√£o
Mover a chamada `this.changed('password_hash', true)` do hook `beforeValidate` para o **setter do campo virtual `password`**, garantindo que o Sequelize detecte a mudan√ßa ANTES de determinar quais campos incluir no UPDATE.

### Mudan√ßas Realizadas

#### Backend

**Arquivo:** `backend/src/models/User.js`

**Mudan√ßa 1: Setter do campo virtual `password` (linhas 207-217)**
- Adicionada chamada `this.changed('password_hash', true)` no final do setter
- Adicionada documenta√ß√£o explicando o fix v2
- Mantida l√≥gica existente de marcar `_passwordNeedsHash`

**Mudan√ßa 2: Hook `beforeValidate` (linhas 283-297)**
- Mantida chamada `user.changed('password_hash', true)` como redund√¢ncia segura
- Adicionada documenta√ß√£o explicando o fix v3
- Mantida l√≥gica existente de hash da senha

**Resultado:**
```javascript
// No setter (linha 207-217):
set(value) {
  if (value) {
    this.setDataValue('password', value);
    this._passwordNeedsHash = value;
    // CR√çTICO: Marcar que password_hash ser√° alterado
    // Deve ser feito no setter para que Sequelize inclua no UPDATE
    this.changed('password_hash', true);
  }
}

// No hook (mantido como redund√¢ncia):
beforeValidate: async (user) => {
  if (user._passwordNeedsHash) {
    const password = user._passwordNeedsHash;
    const hash = await bcrypt.hash(password, BCRYPT_SALT_ROUNDS);
    user.password_hash = hash;
    user.changed('password_hash', true); // Redund√¢ncia segura
    delete user._passwordNeedsHash;
  }
}
```

---

## 4. ARQUIVOS MODIFICADOS

### User.js (Model)
**Caminho:** `backend/src/models/User.js`

**Mudan√ßas:**
- ‚úÖ Adicionado `this.changed('password_hash', true)` no setter do campo `password` (linha 215)
- ‚úÖ Mantido `user.changed('password_hash', true)` no hook `beforeValidate` (linha 293)
- ‚úÖ Atualizada documenta√ß√£o explicando ambos os fixes

**C√≥digo Relevante (setter):**
```javascript
set(value) {
  if (value) {
    this.setDataValue('password', value);
    this._passwordNeedsHash = value;
    // Marcar explicitamente que password_hash ser√° alterado
    // CR√çTICO: Deve ser feito no setter para que Sequelize inclua no UPDATE
    this.changed('password_hash', true);
  }
}
```

---

## 5. VALIDA√á√ïES ADICIONADAS

### Valida√ß√µes de Entrada
- Mantidas valida√ß√µes existentes de senha (6-100 caracteres)

### Tratamento de Erros
- Mantido tratamento de erros existente no model

### Testes Preventivos
- Criado teste de debug (`teste-debug-senha.js`) para rastrear comportamento detalhado
- Teste original (`teste-senha.js`) agora passa com sucesso

**Output do teste corrigido:**
```
Executing (default): UPDATE `users` SET `password_hash`=?,`updated_at`=? WHERE `id` = ?
Hash antigo: $2b$10$Tz6ys.KQiYxBz...
Hash novo: $2b$10$PXDF4aUeUAFuV...
Hash foi alterado? ‚úì SIM
Nova senha v√°lida? ‚úì SIM
Senha antiga inv√°lida? ‚úì SIM
```

---

## 6. IMPACTO E DEPEND√äNCIAS

### Features Impactadas
- Nenhuma outra feature impactada (corre√ß√£o isolada ao model User)

### Depend√™ncias Adicionadas/Atualizadas
- Nenhuma depend√™ncia adicionada ou atualizada

### Breaking Changes
- [x] N√£o
- **Nenhuma breaking change:** A corre√ß√£o apenas faz o comportamento esperado funcionar corretamente

---

## 7. CHECKLIST DE VALIDA√á√ÉO

- [x] O problema original foi resolvido
- [x] N√£o foram introduzidos novos bugs
- [x] O c√≥digo est√° documentado
- [x] README.md n√£o necessita atualiza√ß√£o (funcionalidade interna)
- [x] Valida√ß√µes e tratamento de erros adequados
- [x] Segue padr√µes do 'docs/contextDoc.md'
- [x] Sem c√≥digo comentado ou console.log desnecess√°rios
- [x] Testado localmente com sucesso
- [x] Compatibilidade mantida

---

## 8. TESTES REALIZADOS

### Cen√°rios Testados
1. **Atualiza√ß√£o de senha em usu√°rio existente** - ‚úÖ Passou
   - Carregar usu√°rio existente
   - Atribuir nova senha via `user.password = 'nova'`
   - Salvar com `user.save()`
   - Verificar que hash foi alterado
   - Validar nova senha funciona
   - Validar senha antiga n√£o funciona mais

2. **Cria√ß√£o de novo usu√°rio com senha** - ‚úÖ Passou (testado previamente em test-user-create.js)
   - Criar usu√°rio com `User.create({ password: 'senha' })`
   - Verificar hash foi gerado
   - Validar senha funciona

3. **Debug detalhado do ciclo de vida** - ‚úÖ Passou (teste-debug-senha.js)
   - Rastrear `_passwordNeedsHash` em cada etapa
   - Verificar `changed()` inclui `password_hash`
   - Confirmar SQL inclui `password_hash` no UPDATE

### Casos de Borda Validados
- ‚úÖ Atualizar senha m√∫ltiplas vezes em sequ√™ncia
- ‚úÖ Senha com caracteres especiais
- ‚úÖ Senha com comprimento m√≠nimo (6) e m√°ximo (100)

---

## 9. PR√ìXIMOS PASSOS

### Recomenda√ß√µes
1. Manter testes de senha (`teste-senha.js`) na su√≠te de testes
2. Considerar adicionar testes automatizados com framework de testes (Jest/Mocha) em features futuras
3. Documentar o padr√£o de "changed() no setter" para futuros campos virtuais que afetam campos reais

### A√ß√µes Futuras
- [ ] Adicionar teste automatizado de atualiza√ß√£o de senha quando configurar Jest/Mocha
- [ ] Revisar outros campos virtuais (se houver) para garantir mesmo padr√£o

### Features Relacionadas para Revisar
- Nenhuma revis√£o necess√°ria

---

## 10. NOTAS ADICIONAIS

### Li√ß√µes Aprendidas
**Sobre o ciclo de vida do Sequelize:**
- O Sequelize determina campos alterados ANTES de executar hooks de valida√ß√£o
- Para campos virtuais que afetam campos reais, a marca√ß√£o de mudan√ßa deve ocorrer no SETTER
- Hooks `beforeValidate/beforeUpdate` s√£o executados tarde demais para influenciar quais campos o Sequelize inclui no UPDATE

**Sobre debugging:**
- Criar testes de debug intermedi√°rios foi crucial para identificar o timing exato do problema
- Observar o SQL gerado (com `logging: console.log` no Sequelize) √© essencial para troubleshooting

### Decis√µes T√©cnicas
**Por que manter `changed()` tanto no setter quanto no hook?**
- Setter: Garante que Sequelize inclua no UPDATE (essencial)
- Hook: Redund√¢ncia segura caso futuros refactorings alterem o comportamento
- N√£o causa problemas chamar `changed()` m√∫ltiplas vezes para o mesmo campo

**Por que n√£o fazer hash diretamente no setter?**
- `bcrypt.hash()` √© ass√≠ncrono (retorna Promise)
- Setters do Sequelize n√£o suportam opera√ß√µes ass√≠ncronas
- Abordagem atual (marcar para hash + processar no hook) mant√©m separa√ß√£o de responsabilidades

---

**Ajuste conclu√≠do em:** 2025-10-26 14:30
**Revisado por:** Aguardando revis√£o
